I"ö)<p>Merhaba, Ruby 3 2020 AralÄ±k ayÄ±nda yayÄ±na Ã§Ä±kmÄ±ÅŸ olacak. GÃ¼zel Ã¶zelliklerle geliyor olsa da bu Ã¶zelliklerden hangilerinin hala Ruby 3 iÃ§erisinde olup olmayacaÄŸÄ± tartÄ±ÅŸma konusu.</p>

<p>Deneysel Ã¶zelliklerin bir kÄ±smÄ± Ruby 2.7 ile bizlerin kullanÄ±lÄ±mÄ±na sunuluyor ve deneme, test etme ÅŸansÄ± buluyoruz. Bu yazÄ±da Ruby 3â€™de gÃ¶rmemiz muhtemelen birkaÃ§Ä±ndan bahsedeceÄŸim.</p>

<p>Matz geÃ§enlerde Github sponsorlarÄ±na bir anket gÃ¶nderdi. Anket, hangi Ã¶zelliÄŸi Ruby 3â€™de gÃ¶rmek istediÄŸimiz ile alakalÄ±ydÄ±. SeÃ§enekler arasÄ±nda ise ÅŸu Ã¶zellikler vardÄ±:</p>

<ul>
  <li>Ractor</li>
  <li>JIT</li>
  <li>Type Profiler / Static Type Analysis</li>
  <li>Heap Compaction (GC Improvement)</li>
  <li>Pattern Matching</li>
  <li>Right Assignment</li>
</ul>

<p>Åimdi bunlara tek tek bakalÄ±m.</p>

<h2 id="ractor">Ractor</h2>

<p>Eski adÄ± Guild olan bir Ã¶zellikte Ã§alÄ±ÅŸan Koichi Sasada Matzâ€™Ä±n da Ã¶nerisi ile adÄ±nÄ± Ractorâ€™a Ã§evirdi. MantÄ±ÄŸÄ±nÄ±n ise <code class="language-plaintext highlighter-rouge">"Ractor," Ruby's Actor-like feature (not an exact Actor-model)</code> geldiÄŸini sÃ¶ylÃ¼yor. Konu aslÄ±nda MRI Rubyâ€™nin kodu parallel Ã§alÄ±ÅŸtÄ±rmasÄ±na izin vermemesinden geliyor. Guild yani yeni ismi ile Ractor, Ruby iÃ§in yeni bir concurrency modeli Ã¶neriyor. Burada asÄ±l amaÃ§ Ruby 3 ile bu modeli kurarken Ruby 2 ile uyumluluÄŸu korumak ve parallel Ã§alÄ±ÅŸabilecek parÃ§alarÄ± ve objeleri hÄ±zlÄ± bir ÅŸekilde paylaÅŸÄ±mÄ±na izin vermek. Rubyâ€™deki yaygÄ±n concurrency problemlerden biri threadâ€™lerin race conditionâ€™lar oluÅŸturup, oluÅŸturmadÄ±ÄŸÄ±ndan emin olmaktÄ±r. Rubyâ€™deki <code class="language-plaintext highlighter-rouge">Thread::Mutex</code> ile bunun Ã¶nÃ¼ne geÃ§ebilirsiniz fakat bu sefer de paralelliÄŸi ortadan kaldÄ±rmÄ±ÅŸ ya da yavaÅŸlatmÄ±ÅŸ olursunuz.</p>

<p>Rubyâ€™de Thread ve Fiber olmak Ã¼zere iki tane sÄ±nÄ±f var. Threadâ€™ler iÅŸletim sistemi seviyesinde kodun parallel Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlarken, Fiber ise parallel Ã§alÄ±ÅŸacak kodlarÄ±n manuel olarak planlamasÄ±nÄ±n yapÄ±lmasÄ±na izin verir. Guildâ€™Ä± ise bu ikisinin birlikte uygulanmasÄ± ile ortaya Ã§Ä±kar. ÅÃ¶yle diyebiliriz; Bir Guild iÃ§erisinde en az bir Thread ve onun da iÃ§erisinde en az bir Fiber bulunur. Guild iÃ§erisindeki Threadâ€™ler paralel Ã§alÄ±ÅŸamazken, farklÄ± Guildâ€™dekiler Ã§alÄ±ÅŸabilir.</p>

<p>Bir Guildâ€™deki mutable bir obje baÅŸka bir Guildâ€™den obje tarafÄ±ndan okunamaz ya da deÄŸiÅŸtirilemez. Bu sebeple Guildâ€™lerin parallel Ã§alÄ±ÅŸmasÄ± saÄŸlanÄ±r. <code class="language-plaintext highlighter-rouge">Guild::Channel</code> ile bunu yapmak da mÃ¼mkÃ¼ndÃ¼r. Bu yÃ¶ntem ile bir obje diÄŸer Guildâ€™de kopyalanÄ±r ve ilgili Guildâ€™e gÃ¶nderilir.</p>

<p>Ractor (Guild) ile alakalÄ± daha fazla bilgiye ve Ã¶rneÄŸe buradan ulaÅŸabilirsiniz. <a href="https://github.com/ko1/ruby/blob/ractor_parallel/doc/ractor.md">https://github.com/ko1/ruby/blob/ractor_parallel/doc/ractor.md</a></p>

<p>SonuÃ§ta bu Ã¶zellik ile artÄ±k Rubyâ€™de thread-safe konularÄ±na kafayÄ± takmadan paralel iÅŸler yapabileceÄŸiz gibi duruyor.</p>

<h2 id="jit">JIT</h2>

<p>Uzun adi Just In Compile olan JIT Ruby programlarÄ±nÄ±n makine kodlarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. DiÄŸer derleyicilerden farklÄ± olarak bÃ¼tÃ¼n kod derlemez sadece kodun deÄŸiÅŸtirilen yerlerini derler. JIT ne kadar hÄ±zlanma getirir ve neler gÃ¶tÃ¼rÃ¼r bu konuda bazÄ± Ã§alÄ±ÅŸmalar <a href="https://eregon.me/blog/2016/11/28/optcarrot.html">https://eregon.me/blog/2016/11/28/optcarrot.html</a> olsa da yorumlanan bir Rubyâ€™den daha hÄ±zlÄ± olacaÄŸÄ± kesin.</p>

<p>JITâ€™in avantajÄ± kadar yanÄ±nda getirdiÄŸi ve muhtemelen geliÅŸtirilecek bir takÄ±m dezavantajlarÄ± da var. Bunlardan biri memory kullanÄ±mÄ± diÄŸeri ise warmup sÃ¼resinin uzunluÄŸu.</p>

<p>BildiÄŸim kadarÄ± ile JIT ÅŸuan Ruby 2.6â€™da var ve <code class="language-plaintext highlighter-rouge">-jit</code> flagâ€™i ile kullanÄ±labiliyor. Ruby on Rails gibi bÃ¼yÃ¼k gemâ€™lerde henÃ¼z kullanÄ±lmÄ±yor diye biliyorum ancak daha kÃ¼Ã§Ã¼k iÅŸler iÃ§in tercih edilebilir.</p>

<p>JIT konusu hakkÄ±nda Ã§alÄ±ÅŸan Takashi Kokubun, Ruby Rouges podcastâ€™ine konuk olmuÅŸ. Daha fazla detayÄ± <a href="https://devchat.tv/ruby-rogues/rr-470-performance-improvement-of-ruby-3-0-jit-with-takashi-kokubun/">buradan</a> dinleyebilirsiniz.</p>

<h2 id="type-profiler--static-type-analysis">Type Profiler / Static Type Analysis</h2>

<p>Tip kontrolÃ¼ ve statik tipli bir dil olmaya doÄŸru giden Ruby, bu Ã¶zelliÄŸi ile beni de heyecanlandÄ±rÄ±yor. Dinamik bir dil olan Rubyâ€™nin statik bir dil olma yolunda attÄ±ÄŸÄ± adÄ±mlardan biri RBS <a href="https://github.com/ruby/rbs">https://github.com/ruby/rbs</a> dili diyebiliriz. RBS, Ruby 3 iÃ§in bir tip imzalama dili. Typeâ€™larÄ± olan kodlar artik RBS dosyalarÄ± iÃ§ine yazÄ±lmaya baÅŸlÄ±yor ki bu da mevcut Ruby kodunun karÄ±ÅŸmasÄ±nÄ± engelliyor.</p>

<p>AslÄ±nda ÅŸuan Sorbet projesi ile type check yapÄ±labiliyor. Sorbet ve Ruby geliÅŸtiricileri RBS iÃ§in birlikte iÅŸler Ã§Ä±karmaya Ã§alÄ±ÅŸÄ±yorlar.</p>

<p>Herkes RBS kullanmak zorunda deÄŸil tabiki ama tiplerin ve tip kontrolÃ¼nÃ¼n gelmesi Rubyâ€™e daha fazla gÃ¼Ã§ ve Ã§eÅŸitlilik katacaktÄ±r diye dÃ¼ÅŸÃ¼nÃ¼yorum. YazÄ±lan kodun kalitesi ve hata oranÄ± ne kadar azalsa da dinamik bir dilde program yazmak, statik bir dile gÃ¶re her zaman daha hÄ±zlÄ± olacaÄŸÄ± da aÅŸikar.</p>

<h2 id="heap-compaction-gc-improvement">Heap Compaction (GC Improvement)</h2>

<p>Rubyâ€™de garbage collection gibi bellek yÃ¶netim iÅŸleri ile pek uÄŸraÅŸmaya gerek yok. Zaten en gÃ¼zel yanÄ± da bu deÄŸil mi? :) Ancak iÅŸler karmaÅŸÄ±klaÅŸtÄ±kca ve programlar bÃ¼yÃ¼dÃ¼kce programlama dillerinin de kendi garbage collectorâ€™larÄ±nda geliÅŸtirmeler yapmasÄ± gerekir.</p>

<p>Ruby 2.7 ile aslÄ±nda ÅŸuan kullanÄ±labilen heap compaction Ã¶zelliÄŸi ile Rubyâ€™de garbage collector daha verimli bir hale geldi. Bu Ã¶zellik sayesinde program iÃ§in memoryâ€™de kullanÄ±lmak istenen alana heap denir. Bu heap objeler iÃ§in kullanÄ±ldikca veya heap iÃ§indeki objeler serbest kaldÄ±kca memory iÃ§erisinde boÅŸluklar oluÅŸur ve memory daÄŸÄ±nÄ±k bir hale gelir. AyrÄ±lan bÃ¼tÃ¼n hafÄ±zayÄ± birlikte kullanmaktansa heap iÃ§indeki kullanÄ±lan memory sÄ±kÄ±ÅŸtÄ±rÄ±lÄ±r boÅŸluklar da deÄŸerlendirilmiÅŸ olur.</p>

<h2 id="pattern-matching">Pattern Matching</h2>

<p>Ruby 2.7 ile hayatÄ±mÄ±za giren bu Ã¶zelliÄŸe pek Ä±sÄ±ndÄ±m diyemem. Ama seveni de vardÄ±r elbet. Elixir kullananlar zaten bu Ã¶zelliÄŸe aÅŸinadÄ±rlar. KÃ¼Ã§Ã¼k bir Ã¶rnekle anlatacak olursak</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nb">name</span><span class="p">,</span> <span class="n">surname</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:foo</span><span class="p">,</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="nb">name</span> <span class="c1">#=&gt; :foo</span>
<span class="n">surname</span> <span class="c1">#=&gt; "bar"</span>
</code></pre></div></div>

<p>ancak eÅŸitliÄŸin iki tarafÄ±ndaki pattern ayni olmadÄ±ÄŸÄ± vakit sorun Ã§Ä±kacaktÄ±r. Ã–rneÄŸin <code class="language-plaintext highlighter-rouge">[name, surname, 30] = [:foo, "bar", 20]</code> bu ÅŸekilde yaparsak hata alacaÄŸÄ±z.</p>

<p>Pattern Matching iÅŸimize daha Ã§ok if veya when statementâ€™larda iÅŸimize yarayacak gibi duruyor. Daha fazlasÄ±Â Hashâ€™lerde ve Arrayâ€™lerde de bu Ã¶zellik Ã§okÃ§a kullanÄ±labilir. Ancak tehlikeli olan ÅŸu ki yeni syntax biraz kafa karÄ±ÅŸtÄ±rÄ±cÄ± ve alÄ±ÅŸmasÄ± zor olabilir. BazÄ± karÄ±ÅŸÄ±k conditionâ€™lar iÃ§in yararlÄ± gibi duruyor ancak kullanÄ±mÄ± o kadar kolay olduÄŸunu sÃ¶yleyemem.</p>

<h3 id="right-assignment">Right Assignment</h3>

<p>Neden diye sordurttan bir Ã¶zellik daha. Soldan saÄŸa kod okumaya alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z iÃ§in bu Ã¶zellik bizlere biraz zor gelecektir.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="s1">'hello'</span> <span class="o">=&gt;</span> <span class="n">foo</span> <span class="c1"># This is equivalent to foo = 'hello'</span>
</code></pre></div></div>

<p>Burada Ã§ok anlamlÄ± deÄŸil ama ÅŸu Ã¶rnek iÃ§in gÃ¼zel duruyor.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">full_name</span>
  <span class="p">[</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">full_name</span> <span class="o">=&gt;</span> <span class="nb">name</span><span class="p">,</span> <span class="n">surname</span>
</code></pre></div></div>

<p>aslÄ±nda burada yapÄ±lmak istenden <code class="language-plaintext highlighter-rouge">name, surname = full_name</code></p>

<h3 id="sonuÃ§">SonuÃ§</h3>

<p>TÃ¼m bunlar tabiki bu kadar az deÄŸil. Ã‡ok fazla detayÄ±n olduÄŸu ve dikkatli bakÄ±ldÄ±ÄŸÄ±nda hepsi Rubyâ€™e bir ÅŸekilde birÅŸeyler katacak Ã¶zellikler. Benim ÅŸahsi fikrim Ruby zaten rahat yazÄ±labilen ve okunabilen bir dil. BazÄ± performans problemleri de halledildikten sonra daha iyi bir dil olacaÄŸÄ± kesin. Ruby 3 ile umarim performansa yÃ¶nelik geliÅŸtirmelere daha fazla Ã¶nem verirler.</p>

<p>Sevgiler.</p>

<p><em>Referanslar:</em></p>

<ul>
  <li><a href="https://bugs.ruby-lang.org/issues/17100">https://bugs.ruby-lang.org/issues/17100</a></li>
  <li><a href="https://olivierlacan.com/posts/concurrency-in-ruby-3-with-guilds/">https://olivierlacan.com/posts/concurrency-in-ruby-3-with-guilds/</a></li>
  <li><a href="https://engineering.appfolio.com/appfolio-engineering/2017/12/26/ruby-3-and-jit-where-when-and-how-fast">https://engineering.appfolio.com/appfolio-engineering/2017/12/26/ruby-3-and-jit-where-when-and-how-fast</a></li>
  <li><a href="https://developer.squareup.com/blog/the-state-of-ruby-3-typing/">https://developer.squareup.com/blog/the-state-of-ruby-3-typing/</a></li>
  <li><a href="https://stackify.com/how-does-ruby-garbage-collection-work-a-simple-tutorial/">https://stackify.com/how-does-ruby-garbage-collection-work-a-simple-tutorial/</a></li>
  <li><a href="https://www.toptal.com/ruby/ruby-pattern-matching-tutorial">https://www.toptal.com/ruby/ruby-pattern-matching-tutorial</a></li>
  <li><a href="https://bugs.ruby-lang.org/issues/15921">https://bugs.ruby-lang.org/issues/15921</a></li>
  <li><a href="https://blog.saeloun.com/2020/08/31/ruby-adds-experimental-rightward-assignment.html">https://blog.saeloun.com/2020/08/31/ruby-adds-experimental-rightward-assignment.html</a></li>
</ul>
:ET